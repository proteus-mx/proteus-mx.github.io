<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA 3D Simulation - V0.9</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
       <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0GXQFMX3WV"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-0GXQFMX3WV');
    </script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #unravelButton, #autoTourButton {
            position: absolute;
            bottom: 10px;
            padding: 8px;
            background: #333;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 14px;
        }
        #unravelButton { left: calc(50% - 160px); }
        #autoTourButton { left: calc(50% + 110px); }
        #header {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 12px;
            border-radius: 4px;
            text-align: center;
            max-width: 80%;
        }
        #info, #sequencePanel, #focusPanel, #factsPanel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            max-width: 200px;
            text-align: right;
        }
        #info {
            top: 100px;
            right: 10px;
        }
        #sequencePanel {
            top: 200px;
            right: 10px;
            max-width: 100px;
        }
        #focusPanel {
            top: 130px;
            left: 10px;
            max-width: 100px;
            text-align: left;
        }
        #factsPanel {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 300px;
            text-align: center;
        }
        #header h1 {
            font-size: 24px;
            margin: 0 0 8px;
        }
        #header p {
            font-size: 14px;
            margin: 3px 0;
        }
        #sequencePanel h2, #focusPanel h2, #factsPanel h2 {
            font-size: 18px;
            margin: 0 0 6px;
        }
        #info p, #info ul, #sequencePanel p, #focusPanel p {
            font-size: 10px;
            margin: 3px 0;
        }
        #factsPanel p {
            font-size: 14px;
            margin: 3px 0;
        }
        #info ul {
            list-style: none;
            padding: 0;
        }
        #info li {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin: 3px 0;
        }
        .color-box {
            width: 10px;
            height: 10px;
            margin-left: 6px;
            display: inline-block;
        }
        #sequenceList, #focusList {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-family: monospace;
            font-size: 12px;
            margin: 0;
            padding: 0;
            list-style: none;
        }
        #focusList {
            align-items: flex-start;
        }
        #sequenceList li, #focusList li {
            margin: 2px 0;
        }
        .base-A { color: #ff3333; }
        .base-T { color: #33ff33; }
        .base-G { color: #3333ff; }
        .base-C { color: #ffff33; }
    </style>
</head>
<body>
    <button id="unravelButton">Unravel DNA</button>
    <button id="autoTourButton">Start Auto Tour</button>
    <div id="header">
        <h1>DNA 3D Simulation</h1>
        <p>Explore a dynamic 3D model of DNA. Use mouse to rotate, zoom, and pan, or click "Auto Tour" for a guided view with multiple angles.</p>
    </div>
    <div id="info">
        <p><strong>Key:</strong></p>
        <ul>
            <li>Adenine (A)<span class="color-box" style="background: #ff3333;"></span></li>
            <li>Thymine (T)<span class="color-box" style="background: #33ff33;"></span></li>
            <li>Guanine (G)<span class="color-box" style="background: #3333ff;"></span></li>
            <li>Cytosine (C)<span class="color-box" style="background: #ffff33;"></span></li>
            <li>Backbone<span class="color-box" style="background: #aaaaaa;"></span></li>
            <li>Bonds<span class="color-box" style="background: #cccccc;"></span></li>
        </ul>
    </div>
    <div id="sequencePanel">
        <h2>DNA Sequence (5' to 3')</h2>
        <ul id="sequenceList"></ul>
    </div>
    <div id="focusPanel">
        <h2>Focus Sequence</h2>
        <ul id="focusList"></ul>
    </div>
    <div id="factsPanel">
        <h2>DNA Facts</h2>
        <p id="factText"></p>
    </div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Camera position
        camera.position.set(0, 5, 15);
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        // DNA parameters
        const radius = 1.2;
        const height = 20;
        const segments = 100;
        const basePairs = 60;
        const twist = 10;

        // Materials for base pairs
        const materials = {
            A: new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.4, metalness: 0.2 }),
            T: new THREE.MeshStandardMaterial({ color: 0x33ff33, roughness: 0.4, metalness: 0.2 }),
            G: new THREE.MeshStandardMaterial({ color: 0x3333ff, roughness: 0.4, metalness: 0.2 }),
            C: new THREE.MeshStandardMaterial({ color: 0xffff33, roughness: 0.4, metalness: 0.2 })
        };
        const backboneMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.6, metalness: 0.1 });
        const bondMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5, metalness: 0.3 });

        // DNA state
        let isUnraveled = false;
        let unravelProgress = 0;
        let dnaSequence = [];
        let isAutoTour = false;
        let tourProgress = 0;
        let currentPosition = new THREE.Vector3(0, 5, 15);
        let currentTarget = new THREE.Vector3(0, 0, 0);
        let targetPosition = new THREE.Vector3();
        let targetLookAt = new THREE.Vector3();

        // DNA facts
        const dnaFacts = [
            "DNA stands for Deoxyribonucleic Acid.",
            "A human DNA strand contains about 3 billion base pairs.",
            "DNA is stored in the nucleus of cells.",
            "Adenine pairs with Thymine, Guanine with Cytosine.",
            "DNA replicates before cell division.",
            "The double helix structure was discovered in 1953.",
            "Genes are segments of DNA that code for proteins.",
            "DNA is about 2 nanometers wide."
        ];
        let factIndex = 0;
        const factText = document.getElementById('factText');
        function updateFact() {
            factText.textContent = dnaFacts[factIndex];
            factIndex = (factIndex + 1) % dnaFacts.length;
        }
        updateFact();
        setInterval(updateFact, 5000);

        // Generate DNA double helix
        function createDNAStrand() {
            const group = new THREE.Group();
            const bases = ['A', 'T', 'G', 'C'];
            const meshes = { bases: [], bonds: [], backbones: [] };
            const initialPositions = [];

            for (let i = 0; i < basePairs; i++) {
                const theta = (i / basePairs) * Math.PI * twist;
                const y = (i / basePairs) * height - height / 2;

                const base1 = bases[Math.floor(Math.random() * 4)];
                const base2 = base1 === 'A' ? 'T' : base1 === 'T' ? 'A' : base1 === 'G' ? 'C' : 'G';
                dnaSequence.push(base1);

                const sphere1 = new THREE.SphereGeometry(0.25, 16, 16);
                const mesh1 = new THREE.Mesh(sphere1, materials[base1]);
                mesh1.position.set(radius * Math.cos(theta), y, radius * Math.sin(theta));
                mesh1.castShadow = true;
                mesh1.receiveShadow = true;
                group.add(mesh1);
                meshes.bases.push(mesh1);
                initialPositions.push({ x: radius * Math.cos(theta), y, z: radius * Math.sin(theta) });

                const sphere2 = new THREE.SphereGeometry(0.25, 16, 16);
                const mesh2 = new THREE.Mesh(sphere2, materials[base2]);
                mesh2.position.set(-radius * Math.cos(theta), y, -radius * Math.sin(theta));
                mesh2.castShadow = true;
                mesh2.receiveShadow = true;
                group.add(mesh2);
                meshes.bases.push(mesh2);
                initialPositions.push({ x: -radius * Math.cos(theta), y, z: -radius * Math.sin(theta) });

                const curve = new THREE.CatmullRomCurve3([mesh1.position, mesh2.position]);
                const tubeGeometry = new THREE.TubeGeometry(curve, 10, 0.06, 8, false);
                const tube = new THREE.Mesh(tubeGeometry, bondMaterial);
                tube.castShadow = true;
                group.add(tube);
                meshes.bonds.push(tube);
            }

            const points1 = [];
            const points2 = [];
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const theta = t * Math.PI * twist;
                const y = t * height - height / 2;
                points1.push(new THREE.Vector3(radius * Math.cos(theta), y, radius * Math.sin(theta)));
                points2.push(new THREE.Vector3(-radius * Math.cos(theta), y, -radius * Math.sin(theta)));
            }

            const curve1 = new THREE.CatmullRomCurve3(points1);
            const curve2 = new THREE.CatmullRomCurve3(points2);
            const tubeGeometry1 = new THREE.TubeGeometry(curve1, segments, 0.12, 16, false);
            const tubeGeometry2 = new THREE.TubeGeometry(curve2, segments, 0.12, 16, false);
            const backbone1 = new THREE.Mesh(tubeGeometry1, backboneMaterial);
            const backbone2 = new THREE.Mesh(tubeGeometry2, backboneMaterial);
            backbone1.castShadow = true;
            backbone2.castShadow = true;
            group.add(backbone1, backbone2);
            meshes.backbones.push(backbone1, backbone2);

            return { group, meshes, initialPositions };
        }

        const { group: dna, meshes, initialPositions } = createDNAStrand();
        scene.add(dna);

        // Update sequence display
        function updateSequenceDisplay() {
            const sequenceList = document.getElementById('sequenceList');
            sequenceList.innerHTML = '';
            for (let i = 0; i < dnaSequence.length; i += 4) {
                const group = dnaSequence.slice(i, i + 4);
                const li = document.createElement('li');
                li.innerHTML = group.map(base => `<span class="base-${base}">${base}</span>`).join(' ');
                sequenceList.appendChild(li);
            }
        }
        updateSequenceDisplay();

        // Update focus sequence display
        function updateFocusDisplay() {
            const focusList = document.getElementById('focusList');
            focusList.innerHTML = '';

            // Determine focus index based on camera's Y position
            const yPos = camera.position.y;
            const dnaHeight = height; // 20
            const normalizedY = (yPos + dnaHeight / 2) / dnaHeight; // Map to 0-1
            const focusIndex = Math.floor(normalizedY * basePairs);
            const startIndex = Math.max(0, focusIndex - 8); // Show 16 bases (8 before, 8 after)
            const endIndex = Math.min(basePairs, focusIndex + 8);
            const focusSequence = dnaSequence.slice(startIndex, endIndex);

            // Display 4 bases per line
            for (let i = 0; i < focusSequence.length; i += 4) {
                const group = focusSequence.slice(i, i + 4);
                const li = document.createElement('li');
                li.innerHTML = group.map(base => `<span class="base-${base}">${base}</span>`).join(' ');
                focusList.appendChild(li);
            }
        }
        updateFocusDisplay();

        // Unravel button
        const unravelButton = document.getElementById('unravelButton');
        unravelButton.addEventListener('click', () => {
            isUnraveled = !isUnraveled;
            unravelButton.textContent = isUnraveled ? 'Reform DNA' : 'Unravel DNA';
            updateSequenceDisplay();
            updateFocusDisplay();
        });

        // Auto tour button
        const autoTourButton = document.getElementById('autoTourButton');
        autoTourButton.addEventListener('click', () => {
            isAutoTour = !isAutoTour;
            autoTourButton.textContent = isAutoTour ? 'Stop Auto Tour' : 'Start Auto Tour';
            controls.enabled = !isAutoTour;
            if (isAutoTour) {
                currentPosition.copy(camera.position);
                currentTarget.set(0, 0, 0);
            }
        });

        function updateDNA() {
            try {
                for (let i = 0; i < basePairs; i++) {
                    const y = (i / basePairs) * height - height / 2;
                    const initPos1 = initialPositions[i * 2];
                    const initPos2 = initialPositions[i * 2 + 1];

                    const mesh1 = meshes.bases[i * 2];
                    const mesh2 = meshes.bases[i * 2 + 1];
                    const x1 = THREE.MathUtils.lerp(initPos1.x, 2, unravelProgress);
                    const x2 = THREE.MathUtils.lerp(initPos2.x, -2, unravelProgress);
                    const z1 = THREE.MathUtils.lerp(initPos1.z, 0, unravelProgress);
                    const z2 = THREE.MathUtils.lerp(initPos2.z, 0, unravelProgress);
                    mesh1.position.set(x1, y, z1);
                    mesh2.position.set(x2, y, z2);

                    const bond = meshes.bonds[i];
                    const oldGeometry = bond.geometry;
                    const curve = new THREE.CatmullRomCurve3([mesh1.position, mesh2.position]);
                    bond.geometry = new THREE.TubeGeometry(curve, 10, 0.06, 8, false);
                    oldGeometry.dispose();
                }

                const points1 = [];
                const points2 = [];
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const y = t * height - height / 2;
                    const initTheta = t * Math.PI * twist;
                    const x1 = THREE.MathUtils.lerp(radius * Math.cos(initTheta), 2, unravelProgress);
                    const x2 = THREE.MathUtils.lerp(-radius * Math.cos(initTheta), -2, unravelProgress);
                    const z1 = THREE.MathUtils.lerp(radius * Math.sin(initTheta), 0, unravelProgress);
                    const z2 = THREE.MathUtils.lerp(-radius * Math.sin(initTheta), 0, unravelProgress);
                    points1.push(new THREE.Vector3(x1, y, z1));
                    points2.push(new THREE.Vector3(x2, y, z2));
                }

                const oldBackbone1Geometry = meshes.backbones[0].geometry;
                const oldBackbone2Geometry = meshes.backbones[1].geometry;
                const curve1 = new THREE.CatmullRomCurve3(points1);
                const curve2 = new THREE.CatmullRomCurve3(points2);
                meshes.backbones[0].geometry = new THREE.TubeGeometry(curve1, segments, 0.12, 16, false);
                meshes.backbones[1].geometry = new THREE.TubeGeometry(curve2, segments, 0.12, 16, false);
                oldBackbone1Geometry.dispose();
                oldBackbone2Geometry.dispose();
            } catch (error) {
                console.error('Error updating DNA:', error);
            }
        }

        function animate() {
            try {
                requestAnimationFrame(animate);

                if (isUnraveled && unravelProgress < 1) {
                    unravelProgress = Math.min(unravelProgress + 0.005, 1);
                    updateDNA();
                } else if (!isUnraveled && unravelProgress > 0) {
                    unravelProgress = Math.max(unravelProgress - 0.005, 0);
                    updateDNA();
                }

                dna.rotation.y += 0.004;

                if (isAutoTour) {
                    tourProgress += 0.01;
                    const cycle = tourProgress % (2 * Math.PI);

                    // Toggle unraveling/raveling during auto tour
                    if (cycle < Math.PI / 2 && !isUnraveled) {
                        isUnraveled = true;
                        unravelButton.textContent = 'Reform DNA';
                    } else if (cycle >= Math.PI && cycle < 3 * Math.PI / 2 && isUnraveled) {
                        isUnraveled = false;
                        unravelButton.textContent = 'Unravel DNA';
                    }

                    // Define target positions and look-at points for each view
                    if (cycle < Math.PI / 2) {
                        // Side view with orbit and zoom
                        const zoomRadius = 10 + 5 * Math.sin(tourProgress * 0.5);
                        targetPosition.set(
                            zoomRadius * Math.sin(tourProgress),
                            5 + 3 * Math.sin(tourProgress * 0.3),
                            zoomRadius * Math.cos(tourProgress)
                        );
                        targetLookAt.set(0, 0, 0);
                    } else if (cycle < Math.PI) {
                        // Angled view with tilt
                        const zoomRadius = 8 + 4 * Math.cos(tourProgress * 0.4);
                        targetPosition.set(
                            zoomRadius * Math.cos(tourProgress * 0.7),
                            10 + 2 * Math.sin(tourProgress * 0.2),
                            zoomRadius * Math.sin(tourProgress * 0.7)
                        );
                        targetLookAt.set(0, 0, 0);
                    } else if (cycle < 3 * Math.PI / 2) {
                        // Top-down view
                        targetPosition.set(
                            2 * Math.sin(tourProgress * 0.5),
                            15 + 3 * Math.sin(tourProgress * 0.3),
                            2 * Math.cos(tourProgress * 0.5)
                        );
                        targetLookAt.set(0, 0, 0);
                    } else {
                        // Diagonal view with pan
                        const zoomRadius = 12 + 3 * Math.sin(tourProgress * 0.6);
                        targetPosition.set(
                            zoomRadius * Math.sin(tourProgress * 0.8),
                            3 + 4 * Math.cos(tourProgress * 0.4),
                            zoomRadius * Math.cos(tourProgress * 0.8)
                        );
                        targetLookAt.set(0, 0, 0);
                    }

                    // Smoothly interpolate position and look-at target
                    currentPosition.lerp(targetPosition, 0.05);
                    currentTarget.lerp(targetLookAt, 0.05);
                    camera.position.copy(currentPosition);
                    camera.lookAt(currentTarget);
                } else {
                    controls.update();
                }

                updateFocusDisplay();
                renderer.render(scene, camera);
            } catch (error) {
                console.error('Animation error:', error);
            }
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            try {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            } catch (error) {
                console.error('Resize error:', error);
            }
        });
    </script>
</body>
</html>
